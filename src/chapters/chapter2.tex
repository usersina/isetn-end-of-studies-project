\chapter{ State of the art }
\newpage

\setcounter{secnumdepth}{0} % Set the section counter to 0 so next section is not counted in toc
% ----------------------- Introduction ----------------------- %
\section{Introduction}
This chapter will present and study various concepts such as Automation, Web Scraping, Version Control, DevOps, State Machine with an emphasis on the DevOps terminology such as the CI/CD pipelines.
We will talk about the most used tools in the market as well as which ones we settled on after making a comparison.

\setcounter{secnumdepth}{2} % Resume counting the sections for the toc with a depth of 2 (Sections and sub-sections)
% ----------------------- DevOps ----------------------- %
\section{Automation and Web Scraping concepts}
\subsection{Automation}
At its core, automation is leaving menial and recurring tasks to the automaton (or machine) in order to do more meaningful work as a human in the meantime.
Implementing automation improves the efficiency, reliability and the speed of tasks that previously took humans a lot of time.
\subsection{Web Scraping}
Web scraping is the process of automatically extracting content and data from a website.
Although data extraction is done in a brute way by reading texts from HTML elements, it is used in a variety of legitimate digital businesses like search engines, price comparison sites and market research companies.
So contrary to what some might think, web scraping is completely legal.
\subsection{Relationship between the two}
Web scraping simplifies the process of extracting data and the automation process helps repeating the recurring task of extraction.
As a result, the combination of scraping data, storing it and automating the whole process is getting very popular, especially with new technologies and tools arising in order to do just that.


% ----------------------- DevOps ----------------------- %
\section{DevOps}

\subsection{Definition}
DevOps is the set of practices, techniques and tools used to speed up the Software Development Lifecycle (SDL) by bringing together two historically separate functions of development and operations.

\medskip
Development refers to writing code and software, whereas operations refer to provisioning servers, configuring them as well as deploying the apps to them, amongst other things.

\medskip
DevOps teams focus on automating all of the above.
The key terminologies around DevOps are Continuous Integration, Continuous Delivery and Infrastructure As Code (IAC).

\subsection{Lifecycle}
\begin{figure}[H]
    \centering
    \makebox[\textwidth]{\includegraphics[width=9cm]{src/assets/images/devops.png}}
    \caption{DevOps lifecycle}
    \label{fig:devops-lifecycle}
\end{figure}
TODO: \lipsum[2]
A continuous integration and continuous deployment (CI/CD) pipeline is a series of steps that must be performed in order to deliver a new version of software.
CI/CD pipelines are a practice focused on improving software delivery throughout the software development life cycle via automation. \cite{cicd-definition}

\subsection{Container management}
Containers have become an integral part of DevOps over the past couple of years but what is a container exactly and how do we manage them?
\subsubsection*{What is a container ?}
Simply said; container is a packaging format for software applications that are akin to a very lightweight virtual machine which always executes in an isolated environment \cite{what-is-a-container}.
What this implies is that said containers can be easily copied to and run on different machines with high reliability, lower costs and high efficiency.
\subsubsection*{What is container management ?}
Container management is the process for automating the creation, deployment and scaling of containers \cite{container-management}.
Container management tools such as Docker and Podman facilitate the addition, replacement and organization of containers.

% ----------------------- Mincroservices ----------------------- %
\section{Microservices}

\subsection{Definition}
Microservices are an architectural and organizational approach to software development where software is composed of small independent services that communicate over well-defined APIs.
These services are owned by small, self-contained teams. \cite{microservices}

\medskip
Microservices architectures make applications easier to scale and faster to develop, enabling innovation and accelerating time-to-market for new features.
\begin{figure}[H]
    \centering
    \makebox[\textwidth]{\includegraphics[width=12cm]{src/assets/images/microservices.png}}
    \caption{Breaking a monolithic application into microservices}
    \label{fig:monolith-to-microservices}
\end{figure}
\subsection{Characteristics of Microservices}
\begin{itemize}
    \item \textbf{Autonomous :} Each component service in a microservices architecture can be developed, deployed, operated, and scaled without affecting the functioning of other services. Services do not need to share any of their code or implementation with other services. Any communication between individual components happens via well-defined APIs.
    \item \textbf{Specialized :} Each service is designed for a set of capabilities and focuses on solving a specific problem. If developers contribute more code to a service over time and the service becomes complex, it can be broken into smaller services.
\end{itemize}

\subsection{Benefits of Microservices}
\begin{itemize}
    \item \textbf{Agility :} Microservices foster an organization of small, independent teams that take ownership of their services. Teams act within a small and well understood context, and are empowered to work more independently and more quickly.
    \item \textbf{Flexible Scaling :} Microservices allow each service to be independently scaled to meet demand for the application feature it supports. This enables teams to right-size infrastructure needs, accurately measure the cost of a feature, and maintain availability if a service experiences a spike in demand.
    \item \textbf{Easy Deployment :} Microservices enable continuous integration and continuous delivery, making it easy to try out new ideas and to roll back if something doesn’t work. The low cost of failure enables experimentation, makes it easier to update code, and accelerates time-to-market for new features.
    \item \textbf{Technical Freedom :} Microservices architectures don’t follow a “one size fits all” approach. Teams have the freedom to choose the best tool to solve their specific problems. As a consequence, teams building microservices can choose the best tool for each job.
    \item \textbf{Reusable Code :} Dividing software into small, well-defined modules enables teams to use functions for multiple purposes. A service written for a certain function can be used as a building block for another feature. This allows an application to bootstrap off itself, as developers can create new capabilities without writing code from scratch.
    \item \textbf{Resilience :} Service independence increases an application’s resistance to failure. In a monolithic architecture, if a single component fails, it can cause the entire application to fail. With microservices, applications handle total service failure by degrading functionality and not crashing the entire application.
\end{itemize}

% ----------------------- Comparative Analysis ----------------------- %
\section{Comparative Analysis}
In order to get started with our project, we need a wide range of tools that deal with the following areas; version control, orchestration between containers, browser automation as well as scheduled automation. For that, we did a comparative study on some of the tools the market provides.

\subsection{Version Control: Git vs SVN}
The most used tools for version control are Git and SVN. Here is a table comparing both tools.
\begin{table}[H]
    \renewcommand{\arraystretch}{1.5}%
    \caption{Comparative study between Git and SVN}
    \centering
    \medskip
    \begin{tabularx}{1\textwidth} {
            | >{\hsize=.5\hsize\linewidth=\hsize\centering\arraybackslash}X
            | >{\hsize=1.25\hsize\linewidth=\hsize\centering\arraybackslash}X
            | >{\hsize=1.25\hsize\linewidth=\hsize\centering\arraybackslash}X |}
        \hline
        \rowcolor{primary} & \textbf {Description}                                                                                                                          & \textbf {Advantages}                                                                                                                                                           \\
        \hline
        \textbf{Git}       & Git is a distributed version control system which means that when coloning a repository, you get a copy of the entire history of that project. & Git has what's called a staging area. This means that even if you made over a 100 changes, they can be broken down to 10 commits each with their own comments and description. \\
        \hline
        \textbf{SVN}       & SVN or Subversion is a centralized version control system. Meaning that there is always a single version of the repository that you checkout.  & SVN has one central repository – which makes it easier for managers to have more of a top down approach to control, security, permissions, mirrors, and dumps.                 \\
        \hline
    \end{tabularx}
\end{table}
At the end, both are great options. However, we will be using Git which is the VCS the company uses.

\subsection{Container management: Docker vs Podman}
Although Docker is widely popular, Podman is also taking its share from the market. Especially on Redhat systems.
\begin{table}[H]
    \renewcommand{\arraystretch}{1.5}%
    \caption{Comparative study between Docker and Podman}
    \centering
    \medskip
    \begin{tabularx}{1\textwidth} {
            | >{\hsize=.7\hsize\linewidth=\hsize\raggedright\arraybackslash}X
            | >{\hsize=1.15\hsize\linewidth=\hsize\raggedright\arraybackslash}X
            | >{\hsize=1.15\hsize\linewidth=\hsize\raggedright\arraybackslash}X |}
        \hline
        \rowcolor{primary} \textbf {Aspect} & \textbf {Docker}                                                                                                                                                                                                                    & \textbf {Podman}                                                                                                                                                            \\
        \hline
        \textbf {Definition}                & \multicolumn{2}{|>{\hsize=2.35\hsize}X|} {Docker and Podman are both  container management technologies used to build container images and store said images in a registry to then run them as containers in a target environment.}                                                                                                                                                                               \\
        \hline
        \textbf {Technology}                & Docker uses the containerd daemon which does the pulling of images then hands over the creation process to a low-level runtime named runc.                                                                                          & Podman uses a daemon-less approach using a technology named conmon which does the heavy lifting. It also delegates the container creation to a low-level container runtime. \\
        \hline
        \textbf {Specificity}               & Docker Desktop is a great feature for Docker which provides an easy way to build and distribute containers amongst developers.                                                                                                      & The smallest unit in Podman is the pod. A pod is the organizational unit for containers and is directly compatible with Kubernetes.                                         \\
        \hline
    \end{tabularx}
\end{table}
As a result, we will also be sticking to Docker in this project.

\subsection{Browser automation: Puppeteer vs Playwright}
Both are Node.js libraries for browser automation. The table below compares these two on different levels.
\begin{table}[H]
    \renewcommand{\arraystretch}{1.5}%
    \caption{Puppeteer vs Playwright highlights}
    \centering
    \medskip
    \begin{tabularx}{1\textwidth} {
            | >{\hsize=.7\hsize\linewidth=\hsize\raggedright\arraybackslash}X
            | >{\hsize=1.15\hsize\linewidth=\hsize\raggedright\arraybackslash}X
            | >{\hsize=1.15\hsize\linewidth=\hsize\raggedright\arraybackslash}X |}
        \hline
        \rowcolor{primary} \textbf {Category} & \textbf {Puppeteer}                                                                                                            & \textbf {Playwright}                                                                                                                                               \\
        \hline
        \textbf {Overview}                    & Puppeteer makes it easy to get started with browser automation. This is in part because of how it interfaces with the browser. & Playwright is very similar to Puppeteer in many respects. The API methods are identical in most cases, and Playwright also bundles compatible browsers by default. \\
        \hline
        \textbf {Community}                   & Has a large community with lots of active projects.                                                                            & Small but active community.                                                                                                                                        \\
        \hline
    \end{tabularx}
\end{table}
Since the difference is pretty minor, we will be sticking to the more recent Playwright.

\subsection{Database: MongoDB vs MySQL}
The old architecture of ILG uses MySQL but we have the choice to use a different database as well, so we did the following study.
\begin{table}[H]
    \renewcommand{\arraystretch}{1.5}%
    \caption{Comparative study between MongoDB and MySQL \cite{mongodb-vs-mysql}}
    \centering
    \medskip
    \begin{tabularx}{1\textwidth} {
            | >{\hsize=.7\hsize\linewidth=\hsize\raggedright\arraybackslash}X
            | >{\hsize=1.15\hsize\linewidth=\hsize\raggedright\arraybackslash}X
            | >{\hsize=1.15\hsize\linewidth=\hsize\raggedright\arraybackslash}X |}
        \hline
        \rowcolor{primary} \textbf {Category} & \textbf {MongoDB}                                                       & \textbf {MySQL}                                                                                    \\
        \hline
        \textbf {Overview}                    & An open-source NoSQL that stores data in JSON-like documents.           & An open-source relational database system.                                                         \\
        \hline
        \textbf {Storage}                     & Stores data in documents that belong to a particular class or group.    & Data is stored in tables where each table corresponds to an entity.                                \\
        \hline
        \textbf {Type}                        & NoSQL, meaning that data in a collection can have different structures. & Uses SQL (Standard Query Language) meaning that the schema of data cannot be changed once defined. \\
        \hline
    \end{tabularx}
\end{table}
Since the old architecture uses MySQL, we will be sticking to that in the new architecture as well for an easier migration.

\subsection{Database: GraphQL vs Rest}
The most used tools for version control are Git and SVN. Here is a table comparing both tools.
\begin{table}[H]
    \renewcommand{\arraystretch}{1.5}%
    \caption{Comparative study between GraphQL and REST \cite{graphql-vs-rest}}
    \centering
    \medskip
    \begin{tabularx}{1\textwidth} {
            | >{\hsize=.6\hsize\linewidth=\hsize\centering\arraybackslash}X
            | >{\hsize=1.2\hsize\linewidth=\hsize\centering\arraybackslash}X
            | >{\hsize=1.2\hsize\linewidth=\hsize\centering\arraybackslash}X |}
        \hline
        \rowcolor{primary} & \textbf {Description}                                                                                                                & \textbf {In depth}                                                                                                                \\
        \hline
        \textbf{GraphQL}   & An open-source data query and manipulation language for APIs, and a runtime for fulfilling queries with existing data.               & Describe only what's needed in queries, so no under or over fetching. It is also Schema and Type safe so it's less prone to bugs. \\
        \hline
        \textbf{REST}      & REST (Representational State Transfer) is an architectural style that conforms to a set of constraints when developing web services. & It was introduced as a successor to SOAP APIs, follows the REST standards and is not constrained to XML.                          \\
        \hline
    \end{tabularx}
\end{table}
Since the old architecture uses MySQL, we will be sticking to it in the new architecture.

\subsection{Deployment: Kubernetes vs Docker Compose}
TODO: The old architecture uses Docker Compose, but we suggested Kubernetes instead.

\setcounter{secnumdepth}{0} % Set the section counter to 0 so next section is not counted in toc
% ----------------------- Conclusion ----------------------- %
\section{Conclusion}
\lipsum[2]
