\chapter{Realization}
\newpage

\setcounter{secnumdepth}{0} % Set the section counter to 0 so next section is not counted in toc
% ----------------------- Introduction ----------------------- %
\section{Introduction}
In this chapter, we will finally discuss the long awaited realization.
This is the implementation phase where all of the work done in the previous chapters comes into picture.
This section will {\bf heavily focus on DevOps} since our primary objective has been migrating the ILG application to a new scalable architecture.
We will start with the new architecture hardware and software setup, present some of the difficulties we encountered and then list all of the technologies we've used for our work.

\setcounter{secnumdepth}{2} % Resume counting the sections for the toc with a depth of 2 (Sections and sub-sections)
% ----------------------- Hardware setup ----------------------- %
\section{Hardware setup}
Since we agreed to proceed with the self-managed Kubernetes deployment as mentioned in \textbf{Chapter 2: State of the art}, we had to create own cluster nodes or virtual machines.
The nodes in question can be separated into the core nodes that are created once, and the scalable nodes that can be created indefinitely.

\subsection{Cloud provider}
To provision the hardware resources that we need for the deployment, we're going  to use the IONOS Cloud provider.
\cite[Ionos is a web hosting company founded in Germany in 1988 and is currently owned by United Internet.]{ionos-wikipedia}
\begin{figure}[H]
    \centering
    \makebox[\textwidth]{\includegraphics[width=10cm]{src/assets/images/ionos-logo.png}}
    \caption{Logo of IONOS}
    \label{fig:logo-of-ionos-cloud}
\end{figure}

IONOS Cloud provides -through the Ionos cloudpanel service- an easy way to create and manage virtual machines, firewall rules, private networks and various other infrastructure components.
\begin{figure}[H]
    \centering
    \makebox[\textwidth]{\includegraphics[width=15cm]{src/assets/images/ionos-cloudpanel-dashboard.JPG}}
    \caption{Ionos cloudpanel dashboard}
    \label{fig:image-of-ionos-cloudpanel-dashboard}
\end{figure}


The two images below show the available VM sizes in the Ionos cloudpanel dashboard that we can pick for our VMs.
Note that will be referenced in the tables below.
\begin{figure}[H]
    \centering
    \makebox[\textwidth]{\includegraphics[width=\linewidth]{src/assets/images/vm-standard.jpg}}
    \caption{Standard VM sizes in IONOS}
    \label{fig:standard-vm-sizes}
\end{figure}
\begin{figure}[H]
    \centering
    \makebox[\textwidth]{\includegraphics[width=\linewidth]{src/assets/images/vm-ram-optimized.JPG}}
    \caption{RAM Optimized VM sizes in IONOS}
    \label{fig:ram-optimized-vm-sizes}
\end{figure}

\subsection{Kubernetes Cluster}
Below are the necessary virtual machines needed to setup a self-managed Kubernetes Cluster.
Please note that
\begin{itemize}
    \item What each of the services represent is already mentioned in \textbf{Chapter 3: Analysis and specification of requirements}
    \item The size column which stands for the specification of the virtual machine is described in the previous section.
    \item The number of servers for \textbf{scraper}, and \textbf{automation} nodes will be scaled depending on the number of clients as mentioned in \textbf{Chapter 3: Analysis and specification of requirements}.
\end{itemize}

\begin{table}[H]
    \renewcommand{\arraystretch}{1.5} % Padding
    \caption{Core cluster nodes}
    \centering
    \medskip
    \begin{tabularx}{1\textwidth} {
            | >{\hsize=1\hsize\linewidth=\hsize\raggedright\arraybackslash}X
            | >{\hsize=1.8\hsize\linewidth=\hsize\raggedright\arraybackslash}X
            | >{\hsize=0.2\hsize\linewidth=\hsize\centering\arraybackslash}X |}
        \hline
        \rowcolor{primary} \textbf{Name} & \textbf{Services}                            & \textbf{Size} \\
        \hline
        \textbf{kube-controller}         & The main Kubernetes cluster controller       & XL            \\
        \hline
        \textbf{data-node}               & postgresdb, ilg-data, ilg-api, ilg-scheduler & L             \\
        \hline
        \textbf{front-node}              & ilg-front                                    & S             \\
        \hline
        \textbf{staging-node}            & postgresdb, all other ilg services           & L             \\
        \hline
    \end{tabularx}
\end{table}

\begin{table}[H]
    \renewcommand{\arraystretch}{1.5} % Padding
    \caption{Scalable cluster nodes}
    \centering
    \medskip
    \begin{tabularx}{1\textwidth} {
            | >{\hsize=1.2\hsize\linewidth=\hsize\raggedright\arraybackslash}X
            | >{\hsize=1.5\hsize\linewidth=\hsize\raggedright\arraybackslash}X
            | >{\hsize=0.3\hsize\linewidth=\hsize\centering\arraybackslash}X |}
        \hline
        \rowcolor{primary} \textbf{Name} & \textbf{Services} & \textbf{Size} \\
        \hline
        \textbf{scraper-node-n}          & ilg-scraper       & RL            \\
        \hline
        \textbf{automation-node-n}       & ilg-automation    & RXL           \\
        \hline
    \end{tabularx}
\end{table}

\subsection{Proxy Servers}
Proxies are used to ensure all requests to LinkedIn come from a single IP address as mentioned in \textbf{Chapter X: ---}

\begin{table}[H]
    \renewcommand{\arraystretch}{1.5} % Padding
    \caption{List of proxy servers}
    \centering
    \medskip
    \begin{tabularx}{1\textwidth} {
            | >{\hsize=1\hsize\linewidth=\hsize\raggedright\arraybackslash}X
            | >{\hsize=1.8\hsize\linewidth=\hsize\raggedright\arraybackslash}X
            | >{\hsize=0.2\hsize\linewidth=\hsize\centering\arraybackslash}X |}
        \hline
        \rowcolor{primary} \textbf{Name} & \textbf{Services}                   & \textbf{Size} \\
        \hline
        \textbf{usp-n}                   & Upstream proxy server running Squid & XS            \\
        \hline
    \end{tabularx}
\end{table}

\newpage
% ----------------------- Software setup ----------------------- %
\section{Software setup}
After setting up our hardware resources, we end up with raw Linux virtual machines with no configuration whatsoever.
We have to create and manage our own Kubernetes instance on it to proceed any further.
We will be using {\bf MicroK8s}.
But before that, we also need to setup some basic configuration.

\subsection{Manual configuration}
For a single virtual machine, we have to do the following setup:

\begin{itemize}
    \item Create a user with sudo permissions
    \item Install the base packages we will be using
    \item Edit the hosts file so that the VM recognizes other VMs by their hostnames
    \item Install MicroK8s to have a single cluster node running on the VM
    \item Join the VM with the master node to have a multi-node cluster.
\end{itemize}

\subsection{Automating the process}
Manually configuring the above can be extremely tedious, unefficient and error prone.
Therefore, we've created {\bf Ansible} scripts or playbooks that do just that. In the end, we simply edit a configuration file and directly run the script.
This has a huge advantange especially when
\begin{itemize}
    \item We want to create a development environment for easy prototyping.
    \item We want to use the exact same setup for future projects.
\end{itemize}

\begin{figure}[H]
    \centering
    \makebox[\textwidth]{\includegraphics[width=13cm]{src/assets/images/ansible-main-script.JPG}}
    \caption{Extract from the Ansible playbook}
    \label{fig:extract-from-ansible-playbook}
\end{figure}

\begin{figure}[H]
    \centering
    \makebox[\textwidth]{\includegraphics[width=12cm]{src/assets/images/ansible-hosts.JPG}}
    \caption{The Ansible hosts configuration}
    \label{fig:image-of-ansible-hosts}
\end{figure}
Note that we've also used a hosts file for development where we tested the setup extensively before trying it on production as seen from \textbf {Figure 10}.

% ----------------------- Application pipeline ----------------------- %
\section{Deployment process}
This section will explain the approach we adopted to continously integrate, deploy and deliver our application as per the best practices of DevOps previoulsy mentioned in \textbf{Chapter 3: State of the art}.
The deployment is currently supported on two different environments; the staging environment where we make sure our application works as intended, and of course the production environment.

\subsection{Adopted strategy}
Since we have multiple microservices, it would not be ideal to interact with our Kubernetes cluster from all of them whenever we make a change.
For that reason we use the following steps to deploy our application.
\begin{itemize}
    \item On code changes on any microservice, we create a new Docker image that we push to a custom container registry.
    \item Once the build is finished, we trigger a multi-project pipeline to a central repository we will call ilg-controller.
    \item The central repository will interact with our Kubernetes cluster to make the final deployment to the correct environment using a custom Helm package that we create.
\end{itemize}

This is further explained in detail in the following sub sections.

\subsection{Linking the cluster to GitLab}
Since we have a Kubernetes cluster and we also use GitLab, we will link the two using the GitLab Kubernetes Agent, or KAS for short.

\begin{figure}[H]
    \centering
    \makebox[\textwidth]{\includegraphics[width=15cm]{src/assets/images/gitlab-kubernetes-agent.JPG}}
    \caption{GitLab Kubernetes Agent}
    \label{fig:gitlab-kubernetes-agent}
\end{figure}

% CI Continuous Integration
\subsection{Continuous Integration}
When developers make code changes to the main branch of any microservice, tests are automatically executed.
If the tests are validated, a new Docker image that incorporates the changes the developers made will be pushed to the container registry and our deployment pipeline will be triggered.
In other words, the new code will be integrated and that actually marks the end of this step.
\begin{figure}[H]
    \centering
    \makebox[\textwidth]{\includegraphics[width=11cm]{src/assets/images/ci-pipeline-extract.JPG}}
    \caption{Extract from the CI pipeline}
    \label{fig:extract-from-ci-pipeline}
\end{figure}

% CD Continuous Deployment
\subsection{Continuous Deployment}
Our ilg-controller repository (where KAS is configured) will choose the correct microservice to deploy depending on the trigger input.
It then sets the necessary environment variables for it and installs it from a custom Helm package we've created for the deployment.

\begin{figure}[H]
    \centering
    \makebox[\textwidth]{\includegraphics[width=11cm]{src/assets/images/cd-makefile-extract.JPG}}
    \caption{Extract from the deployment Makefile}
    \label{fig:extract-from-cd-makefile}
\end{figure}
% NOTE: Continuous delivery is a partly manual process where developers can deploy any changes to customers by simply clicking a button, while continuous deployment emphasizes automating the entire the process.

% Custom Helm Package
\subsection{Custom Helm Package}
Since we agreed to use Helm (refer to \textbf{Chapter 2: State of the art}), we've created a package -or in terms of Helm- a chart of our own to manage the Kubernetes cluster resources.

\begin{figure}[H]
    \centering
    \makebox[\textwidth]{\includegraphics[width=15cm]{src/assets/images/helm-chart-code-extract.JPG}}
    \caption{Extract from the custom Helm Chart}
    \label{fig:extract-from-custom-helm-chart}
\end{figure}

We even integrate a CI/CD pipeline for the Helm chart itself so that new packages are built automatically whenever we make changes to the manifest files.

\begin{figure}[H]
    \centering
    \makebox[\textwidth]{\includegraphics[width=15cm]{src/assets/images/build-pacakge-stage.JPG}}
    \caption{Extract from the custom Helm package's pipeline}
    \label{fig:build-package-stage}
\end{figure}

\begin{figure}[H]
    \centering
    \makebox[\textwidth]{\includegraphics[width=15cm]{src/assets/images/gitlab-package-registry.JPG}}
    \caption{GitLab's package registry}
    \label{fig:gitlab-package-registry}
\end{figure}

\newpage
% ----------------------- Technologies ----------------------- %
\section{Technologies}
This part is reserved for the presentation of all of the software used in the realization of the project and includes but is not limited to; programming languages, frameworks, technologies, etc...

\medskip
For a comparative analysis on some of our choices, see \textbf {Chapter 2: State of the art}.
% NOTE: Transform into a table if total page number goes over 70 or so

\begin{itemize}
    \item \textbf{Git:} \newline
          \begin{minipage}{\linewidth}
              \centering
              \includegraphics[width=2.5cm]{src/assets/logos/git_512x512.png}
              \captionof{figure}{Logo of Git}
          \end{minipage}
    \item \textbf{Docker:} \newline
          \begin{minipage}{\linewidth}
              \centering
              \includegraphics[width=4cm]{src/assets/logos/docker_512x512.png}
              \captionof{figure}{Logo of Docker}
          \end{minipage}
    \item \textbf{Playwright:} \newline
          \begin{minipage}{\linewidth}
              \centering
              \includegraphics[width=4.5cm]{src/assets/logos/playwright_512x512.png}
              \captionof{figure}{Logo of Playwright}
          \end{minipage}

          \newpage
    \item \textbf{NestJS:} \newline \cite{nestjs} A framework for building efficient, scalable Node.js web applications. \newline
          \begin{minipage}{\linewidth}
              \centering
              \includegraphics[width=3.7cm]{src/assets/logos/nestjs_512x512.png}
              \captionof{figure}{Logo of NestJS}
          \end{minipage}
    \item \textbf{ReactJS:} \newline A front-end javascript library that's often used as a framework. \newline
          \begin{minipage}{\linewidth}
              \centering
              \includegraphics[width=3.7cm]{src/assets/logos/react_512x512.png}
              \captionof{figure}{Logo of ReactJS}
          \end{minipage}
    \item \textbf{MySQL:} \newline
          \begin{minipage}{\linewidth}
              \centering
              \includegraphics[width=5cm]{src/assets/logos/mysql.png}
              \captionof{figure}{Logo of MySQL}
          \end{minipage}

          \newpage
    \item \textbf{Sequelize:} \newline \cite{sequelize} A modern TypeScript and Node.js ORM for SQL databases. \newline
          \begin{minipage}{\linewidth}
              \centering
              \includegraphics[width=5cm]{src/assets/logos/sequelize_512x512.png}
              \captionof{figure}{Logo of Sequelize}
          \end{minipage}
    \item \textbf{GraphQL:} \newline \cite{graphql} A query language for APIs and a runtime for fulfilling those queries with existing data. \newline
          \begin{minipage}{\linewidth}
              \centering
              \includegraphics[width=3.7cm]{src/assets/logos/graphql_512x512.png}
              \captionof{figure}{Logo of GraphQL}
          \end{minipage}
    \item \textbf{GitLab:} \newline A DevOps software that allows secure collaboration and operations in a single application. \newline
          \begin{minipage}{\linewidth}
              \centering
              \includegraphics[width=3.5cm]{src/assets/logos/gitlab_512x512.png}
              \captionof{figure}{Logo of GitLab}
          \end{minipage}

          \newpage
    \item \textbf{Nginx:} \newline \cite{nginx} A multi-purpose web server can also be used as reverse proxy, load balancer, mail proxy and HTTP cache. \newline
          \begin{minipage}{\linewidth}
              \centering
              \includegraphics[width=3.4cm]{src/assets/logos/nginx_512x512.png}
              \captionof{figure}{Logo of Nginx}
          \end{minipage}
    \item \textbf{Renovate:} \newline A software that provides automatic dependency updates with support for multiple languages. \newline
          \begin{minipage}{\linewidth}
              \centering
              \includegraphics[width=3cm]{src/assets/logos/renovate_200x200.png}
              \captionof{figure}{Logo of Renovate}
          \end{minipage}
    \item \textbf{Docker compose:} \newline A helper tool to run applications with multiple Docker containers using a .YAML format. Used in development. \newline
          \begin{minipage}{\linewidth}
              \centering
              \includegraphics[width=4cm]{src/assets/logos/docker-compose_667x667.png}
              \captionof{figure}{Logo of Docker Compose}
          \end{minipage}

          \newpage
    \item \textbf{Visual Studio Code:} \newline A code editor that's used as an entire development environment with the help of extensions. \newline
          \begin{minipage}{\linewidth}
              \centering
              \includegraphics[width=2.5cm]{src/assets/logos/vscode_512x512.png}
              \captionof{figure}{Logo of VSCode}
          \end{minipage}
    \item \textbf{Linux:} \newline A Unix-like operating system for common daily use and more commonly for servers. \newline
          \begin{minipage}{\linewidth}
              \centering
              \includegraphics[width=3cm]{src/assets/logos/linux_512x512.png}
              \captionof{figure}{Logo of Linux}
          \end{minipage}
    \item \textbf{Make:} \newline GNU Make is used extensively throughout the application to save useful commands for the ease of maintainability. \newline
          \begin{minipage}{\linewidth}
              \centering
              \includegraphics[width=3cm]{src/assets/logos/makefile_512x512.png}
              \captionof{figure}{Logo of Makefile}
          \end{minipage}

          \newpage
    \item \textbf{MicroK8s:} \newline \cite{microk8s} MicroK8s is a simple production-grade conformant K8s. It is Lightweight and focused. \newline
          \begin{minipage}{\linewidth}
              \centering
              \includegraphics[width=3.8cm]{src/assets/logos/microk8s.png}
              \captionof{figure}{Logo of MicroK8s}
          \end{minipage}
    \item \textbf{Kubernetes:} \newline The most powerful tool for managing containerized workloads in the cloud. \newline
          \begin{minipage}{\linewidth}
              \centering
              \includegraphics[width=3.5cm]{src/assets/logos/kubernetes_512x512.png}
              \captionof{figure}{Logo of Kubernetes}
          \end{minipage}
    \item \textbf{Ansible:} \newline An open-source software for provisioning, configuring and managing infrastructure. \newline
          \begin{minipage}{\linewidth}
              \centering
              \includegraphics[width=3.5cm]{src/assets/logos/ansible_200x200.png}
              \captionof{figure}{Logo of Ansible}
          \end{minipage}

          \newpage
    \item \textbf{Squid Proxy:} \newline \cite{squid} Squid is a caching proxy for the Web that supports HTTP, HTTPS, FTP and more. \newline
          \begin{minipage}{\linewidth}
              \centering
              \includegraphics[width=6cm]{src/assets/logos/squid-proxy.png}
              \captionof{figure}{Logo of Squid Proxy}
          \end{minipage}
    \item \textbf{GitLab agent for Kubernetes:} \newline \cite{kas-blog} A secure and reliable way to attach a Kubernetes cluster to GitLab. \newline
          \begin{minipage}{\linewidth}
              \centering
              \includegraphics[width=3.8cm]{src/assets/logos/gitlab-kubernetes-agent_512x512.png}
              \captionof{figure}{Logo of GitLab Agent for Kubernetes}
          \end{minipage}
    \item \textbf{Helm:} \newline Helm is the most popular package manager for Kubernetes. \newline
          \begin{minipage}{\linewidth}
              \centering
              \includegraphics[width=4cm]{src/assets/logos/helm_512x512.png}
              \captionof{figure}{Logo of Helm}
          \end{minipage}

          \newpage
    \item \textbf{LaTeX:} \newline \cite{latex-project} A high-quality document preparation and typesetting system for technical grade documents. \newline
          \begin{minipage}{\linewidth}
              \centering
              \includegraphics[width=4cm]{src/assets/logos/latex_200x200.png}
              \captionof{figure}{Logo of The LaTeX Project}
          \end{minipage}
          %   MSTeams, Asana, Signal?
\end{itemize}

% ----------------------- Difficulties encountered ----------------------- %
\section{Difficulties encountered}
This not persay a technical difficulty as it is more of a limitation from the side of Ionos cloudpanel; the service of IONOS Cloud that we use the provision the needed resources.
To have a full DevOps approach, even the infrastructure should be managed in code -also known as IAC (Infrastructure As Code)- using tools such as Terraform.
However, Ionos cloudpanel does not provide that functionality.
Therefore we had to scrape off the idea and simply create the virtual machines fron the UI everytime we need them.

\setcounter{secnumdepth}{0} % Set the section counter to 0 so next section is not counted in toc
% ----------------------- Conclusion ----------------------- %
\section{Conclusion}
A successfull project comes from a successfull development environment as well as a clean production environment.
For this reason, we spent quite a good amount of time setting up the infrastructure in a clean and scalable way using various tools and script which all comform to the modern ways of how DevOps should be done.
